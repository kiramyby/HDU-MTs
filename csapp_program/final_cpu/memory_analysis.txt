RISC-V数组求和程序执行前后内存变化分析

=== 程序功能概述 ===
这是一个数组求和程序，功能如下：
- 从内存地址0x10（十进制16）开始读取3个连续的32位字
- 将这3个数值进行累加求和  
- 将求和结果存储到内存地址0x30（十进制48）
- 将结果加载到寄存器s0中

=== 初始内存状态 (memory.coe) - 数组求和版本 ===
内存向量: 88888888,99999999,00010fff,20006789,FFFF0000,0000FFFF,88888888,99999999,aaaaaaaa,bbbbbbbb,11111111,22222222,33333333,44444444,55555555,66666666,00000001,00000002,00000003,aaaaaaaa,DEADBEEF,CAFEBABE,FEEDFACE,BADCAFE0,0BADCODE,C0FFEE00,BEEFCAFE,FACEBADD,DEADC0DE,C0DEC0DE...

按地址整理:
地址0:  88888888  
地址1:  99999999  
地址2:  00010fff
地址3:  20006789
地址4:  FFFF0000
地址5:  0000FFFF
地址6:  88888888
地址7:  99999999
地址8:  aaaaaaaa
地址9:  bbbbbbbb
地址10: 11111111
地址11: 22222222
地址12: 33333333
地址13: 44444444
地址14: 55555555
地址15: 66666666
地址16: 00000001  ← 源数组开始 (0x10) 数值1
地址17: 00000002  ← 源数组元素 (0x11) 数值2  
地址18: 00000003  ← 源数组结束 (0x12) 数值3
地址19: aaaaaaaa
地址20: DEADBEEF
...
地址48: FFFFFFFF  ← 结果存储位置 (0x30) 执行前的标记值
...

=== RISC-V程序执行过程 ===
程序参数设置:
- a0 = 0x10 (源数组起始地址，十进制16)
- a1 = 3 (要处理的元素个数)
- a2 = 0x30 (结果存储地址，十进制48)

BankSum函数执行流程:
1. t0 = 0x10 (当前读取地址指针)
2. t1 = 3 (循环计数器)
3. t2 = 0 (累加器初始化)

循环执行过程:
循环1: 读取地址16 → t3 = 00000001, t2 = 0 + 1 = 1, t0 = 20, t1 = 2
循环2: 读取地址17 → t3 = 00000002, t2 = 1 + 2 = 3, t0 = 24, t1 = 1  
循环3: 读取地址18 → t3 = 00000003, t2 = 3 + 3 = 6, t0 = 28, t1 = 0

最终: 将t2 (00000006) 存储到地址48

=== 执行后内存变化 ===
关键内存位置的变化:

源数据区域 (地址16-18) - 保持不变:
地址16 (0x10): 00000001  ✓ 不变 (源数据1)
地址17 (0x11): 00000002  ✓ 不变 (源数据2)
地址18 (0x12): 00000003  ✓ 不变 (源数据3)

结果存储区域 (地址48):
地址48 (0x30): FFFFFFFF → 00000006  ✓ 明显变化 (1+2+3=6)

=== 程序验证 ===
数值计算验证:
- 源数据: 1 + 2 + 3 = 6 (十进制)
- 结果: 6 = 0x00000006 (十六进制)

内存变化验证:
执行前:
- 地址16: 00000001 (源数据)
- 地址17: 00000002 (源数据)  
- 地址18: 00000003 (源数据)
- 地址48: FFFFFFFF (初始标记值)

执行后:
- 地址16: 00000001 (不变)
- 地址17: 00000002 (不变)
- 地址18: 00000003 (不变)  
- 地址48: 00000006 (求和结果)

寄存器最终状态:
- s0 = 00000006 (从地址48加载的求和结果)

=== 总结 ===
这个数组求和程序成功演示了RISC-V CPU的以下功能:
1. 立即数加载 (addi, ori, xori)
2. 函数调用与返回 (jal, jr)
3. 内存读取 (lw)
4. 内存写入 (sw)  
5. 算术运算 (add)
6. 条件分支 (beq)
7. 循环控制结构

变化非常明显且容易验证，便于调试和验证CPU设计的正确性。
