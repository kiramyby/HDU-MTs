RISC-V数组求和程序执行前后内存变化分析 - 修正版

=== 程序功能概述 ===
这是一个数组求和程序，功能如下：
- 从内存地址0x10（十进制16）开始读取3个连续的32位字
- 将这3个数值进行累加求和  
- 将求和结果存储到内存地址0x30（十进制48）
- 将结果加载到寄存器s0中

=== 内存地址映射关系 ===
重要：RISC-V地址到memory.coe位置的映射关系
- 内存控制器使用 DM_Addr[7:2] 作为实际地址
- 即：RISC-V地址 >> 2 = memory.coe中的位置索引

关键地址映射：
- RISC-V地址0x10 (16) → 16>>2 = 4 → memory.coe位置4
- RISC-V地址0x14 (20) → 20>>2 = 5 → memory.coe位置5  
- RISC-V地址0x18 (24) → 24>>2 = 6 → memory.coe位置6
- RISC-V地址0x30 (48) → 48>>2 = 12 → memory.coe位置12

=== 修正后的内存状态 (memory.coe) ===
内存向量: 88888888,99999999,00010fff,20006789,00000001,00000002,00000003,aaaaaaaa,bbbbbbbb,11111111,22222222,44444444,FFFFFFFF,55555555,66666666,77777777...

按memory.coe位置整理:
位置0:  88888888  
位置1:  99999999  
位置2:  00010fff
位置3:  20006789
位置4:  00000001  ← 对应RISC-V地址0x10，源数组第1个元素 = 1
位置5:  00000002  ← 对应RISC-V地址0x14，源数组第2个元素 = 2
位置6:  00000003  ← 对应RISC-V地址0x18，源数组第3个元素 = 3
位置7:  aaaaaaaa
位置8:  bbbbbbbb
位置9:  11111111
位置10: 22222222
位置11: 44444444
位置12: FFFFFFFF  ← 对应RISC-V地址0x30，结果存储位置（执行前标记值）
位置13: 55555555
位置14: 66666666
位置15: 77777777
...

=== RISC-V程序执行过程 ===
程序参数设置:
- a0 = 0x10 (源数组起始地址，十进制16)
- a1 = 3 (要处理的元素个数)
- a2 = 0x30 (结果存储地址，十进制48)

BankSum函数执行流程:
1. t0 = 0x10 (当前读取地址指针)
2. t1 = 3 (循环计数器)
3. t2 = 0 (累加器初始化)

循环执行过程（修正版）:
循环1: 读取地址0x10 (位置4) → t3 = 00000001, t2 = 0 + 1 = 1, t0 = 0x14, t1 = 2
循环2: 读取地址0x14 (位置5) → t3 = 00000002, t2 = 1 + 2 = 3, t0 = 0x18, t1 = 1  
循环3: 读取地址0x18 (位置6) → t3 = 00000003, t2 = 3 + 3 = 6, t0 = 0x1C, t1 = 0

最终: 将t2 (00000006) 存储到地址0x30 (位置12)

=== 执行后内存变化 ===
关键内存位置的变化:

源数据区域 - 保持不变:
位置4 (RISC-V地址0x10): 00000001  ✓ 不变 (源数据1)
位置5 (RISC-V地址0x14): 00000002  ✓ 不变 (源数据2)
位置6 (RISC-V地址0x18): 00000003  ✓ 不变 (源数据3)

结果存储区域:
位置12 (RISC-V地址0x30): FFFFFFFF → 00000006  ✓ 明显变化 (1+2+3=6)

=== 程序验证 ===
数值计算验证:
- 源数据: 1 + 2 + 3 = 6 (十进制)
- 结果: 6 = 0x00000006 (十六进制)

内存变化验证:
执行前:
- 位置4 (0x10): 00000001 (源数据1)
- 位置5 (0x14): 00000002 (源数据2)  
- 位置6 (0x18): 00000003 (源数据3)
- 位置12 (0x30): FFFFFFFF (初始标记值)

执行后:
- 位置4 (0x10): 00000001 (不变)
- 位置5 (0x14): 00000002 (不变)
- 位置6 (0x18): 00000003 (不变)  
- 位置12 (0x30): 00000006 (求和结果)

寄存器最终状态:
- s0 = 00000006 (从地址0x30加载的求和结果)

=== 预期的仿真执行过程 ===
现在使用修正后的memory.coe，仿真应该这样执行：

步骤1-30: 程序初始化和跳转到BankSum函数
步骤31-32: LW指令从地址0x10读取 → 应该得到00000001（而不是之前的FFFF0000）
步骤33-40: 第一次循环，累加器t2 = 1
步骤41-48: LW指令从地址0x14读取 → 应该得到00000002
步骤49-56: 第二次循环，累加器t2 = 3
步骤57-64: LW指令从地址0x18读取 → 应该得到00000003  
步骤65-72: 第三次循环，累加器t2 = 6
步骤73-80: SW指令将结果6存储到地址0x30
步骤81-88: LW指令从地址0x30读取结果到s0寄存器

=== 总结 ===
修正后的memory.coe文件正确地将：
- 数组数据[1,2,3]放置在位置4,5,6（对应RISC-V地址0x10,0x14,0x18）
- 结果存储位置设置为位置12（对应RISC-V地址0x30）

这样程序将能够正确执行数组求和，最终结果为6，存储在s0寄存器中。
此配置成功演示了RISC-V CPU的完整功能集合，包括内存访问、算术运算、循环控制和函数调用。
